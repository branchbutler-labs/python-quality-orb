version: 2.1

description: |
  Python code quality automation for Branch Butler.

  Provides commands and jobs for formatting, linting, static analysis,
  and automated PR reviews. Includes slash command support for
  interactive PR workflows.

display:
  home_url: "https://branchbutler.com"
  source_url: "https://github.com/branchbutler-labs/python-quality-orb"

# Executors
executors:
  python:
    description: "Python executor with pre-installed tools"
    parameters:
      tag:
        type: string
        default: "3.11"
        description: "Python version tag"
      resource-class:
        type: enum
        enum: ["small", "medium", "medium+", "large"]
        default: "medium"
        description: "Resource class for the executor"
    docker:
      - image: cimg/python:<< parameters.tag >>
    resource_class: << parameters.resource-class >>
    environment:
      PYTHONUNBUFFERED: "1"
      PIP_CACHE_DIR: "/tmp/pip-cache"
    working_directory: ~/project

# Commands
commands:
  format:
    description: "Format Python code with Black and isort"
    parameters:
      line-length:
        type: integer
        default: 100
        description: "Maximum line length for Black formatter"
      auto-commit:
        type: boolean
        default: true
        description: "Automatically commit formatting changes"
      paths:
        type: string
        default: "."
        description: "Paths to format (space-separated)"
      isort-profile:
        type: string
        default: "black"
        description: "isort profile to use"
    steps:
      - run:
          name: Install formatters
          command: |
            pip install black isort
      - run:
          name: Run Black formatter
          command: |
            echo "Formatting with Black (line length: << parameters.line-length >>)"
            black --line-length << parameters.line-length >> --check --diff << parameters.paths >> || true
            black --line-length << parameters.line-length >> << parameters.paths >>
      - run:
          name: Run isort
          command: |
            echo "Sorting imports with isort"
            isort --profile << parameters.isort-profile >> --check --diff << parameters.paths >> || true
            isort --profile << parameters.isort-profile >> << parameters.paths >>
      - when:
          condition: << parameters.auto-commit >>
          steps:
            - run:
                name: Commit formatting changes
                command: |
                  git config user.email "bot@branchbutler.com"
                  git config user.name "Branch Butler Bot"

                  if [[ -n $(git status --porcelain) ]]; then
                    git add .
                    git commit -m "style: apply code formatting [skip ci]

                  - Applied Black formatter (line length: << parameters.line-length >>)
                  - Sorted imports with isort

                  ü§ñ Generated by Branch Butler"

                    git push origin HEAD
                    echo "‚úÖ Formatting changes committed and pushed"
                  else
                    echo "‚úÖ No formatting changes needed"
                  fi

  lint:
    description: "Run Python linters and static analysis"
    parameters:
      fail-on-error:
        type: boolean
        default: true
        description: "Fail the job if linting errors are found"
      run-pylint:
        type: boolean
        default: true
        description: "Run pylint"
      run-flake8:
        type: boolean
        default: true
        description: "Run flake8"
      run-mypy:
        type: boolean
        default: true
        description: "Run mypy type checking"
      run-bandit:
        type: boolean
        default: true
        description: "Run bandit security checks"
      max-line-length:
        type: integer
        default: 100
        description: "Maximum line length for linters"
      paths:
        type: string
        default: "."
        description: "Paths to lint"
    steps:
      - run:
          name: Install linters
          command: |
            pip install pylint flake8 mypy bandit
      - when:
          condition: << parameters.run-pylint >>
          steps:
            - run:
                name: Run pylint
                command: |
                  echo "Running pylint..."
                  pylint --max-line-length=<< parameters.max-line-length >> \
                    --output-format=colorized \
                    $(find << parameters.paths >> -name "*.py" | grep -v __pycache__ | head -20) || \
                    if [ "<< parameters.fail-on-error >>" = "true" ]; then exit 1; else true; fi
      - when:
          condition: << parameters.run-flake8 >>
          steps:
            - run:
                name: Run flake8
                command: |
                  echo "Running flake8..."
                  flake8 --max-line-length=<< parameters.max-line-length >> << parameters.paths >> || \
                    if [ "<< parameters.fail-on-error >>" = "true" ]; then exit 1; else true; fi
      - when:
          condition: << parameters.run-mypy >>
          steps:
            - run:
                name: Run mypy
                command: |
                  echo "Running mypy type checking..."
                  mypy << parameters.paths >> || \
                    if [ "<< parameters.fail-on-error >>" = "true" ]; then exit 1; else true; fi
      - when:
          condition: << parameters.run-bandit >>
          steps:
            - run:
                name: Run bandit security checks
                command: |
                  echo "Running bandit security analysis..."
                  bandit -r << parameters.paths >> -f screen || \
                    if [ "<< parameters.fail-on-error >>" = "true" ]; then exit 1; else true; fi

  danger:
    description: "Run Danger for automated PR review"
    parameters:
      github-token:
        type: env_var_name
        default: GITHUB_TOKEN
        description: "Environment variable name for GitHub token"
      min-coverage:
        type: integer
        default: 80
        description: "Minimum test coverage percentage"
      fail-on-warnings:
        type: boolean
        default: false
        description: "Fail if Danger reports warnings"
    steps:
      - run:
          name: Install Danger
          command: |
            pip install danger-python
      - run:
          name: Create Dangerfile
          command: |
            cat > Dangerfile \<<'EOF'
            import os
            from danger_python import Danger

            danger = Danger()

            # Check PR description
            if not danger.github.pr.body or len(danger.github.pr.body) < 10:
                danger.warn("Please provide a detailed PR description.")

            # Check for changelog updates
            has_changelog = any('CHANGELOG' in f or 'changelog' in f
                              for f in danger.git.modified_files + danger.git.created_files)
            if not has_changelog and danger.github.pr.base_ref == 'main':
                danger.warn("Consider updating the CHANGELOG.")

            # Check file sizes
            big_files = [f for f in danger.git.created_files + danger.git.modified_files
                        if os.path.exists(f) and os.path.getsize(f) > 500000]
            if big_files:
                danger.warn(f"Large files detected: {', '.join(big_files)}")

            # Check for TODO comments
            todos = []
            for file in danger.git.modified_files + danger.git.created_files:
                if file.endswith('.py') and os.path.exists(file):
                    with open(file) as f:
                        for i, line in enumerate(f, 1):
                            if 'TODO' in line:
                                todos.append(f"{file}:{i}")
            if todos:
                danger.message(f"TODO comments found:\n" + "\n".join(todos))

            # Success message
            if not danger.warnings and not danger.failures:
                danger.message("‚úÖ All automated checks passed!")
            EOF
      - run:
          name: Run Danger
          command: |
            export DANGER_GITHUB_API_TOKEN=${<< parameters.github-token >>}

            if [ -n "$CIRCLE_PULL_REQUEST" ]; then
              PR_NUM=$(echo $CIRCLE_PULL_REQUEST | sed 's/.*\///')
              danger pr https://github.com/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/pull/$PR_NUM || \
                if [ "<< parameters.fail-on-warnings >>" = "true" ]; then exit 1; else true; fi
            else
              echo "Not a PR build, skipping Danger"
            fi

  rebase:
    description: "Rebase PR branch onto target branch"
    parameters:
      base-branch:
        type: string
        default: "main"
        description: "Base branch to rebase onto"
      auto-resolve-conflicts:
        type: boolean
        default: false
        description: "Attempt to auto-resolve simple conflicts"
      force-push:
        type: boolean
        default: true
        description: "Force push after rebase"
    steps:
      - run:
          name: Configure Git
          command: |
            git config user.email "bot@branchbutler.com"
            git config user.name "Branch Butler Bot"
      - run:
          name: Fetch latest changes
          command: |
            git fetch origin << parameters.base-branch >>
            echo "Fetched latest changes from << parameters.base-branch >>"
      - run:
          name: Rebase branch
          command: |
            echo "Rebasing onto origin/<< parameters.base-branch >>"

            if git rebase origin/<< parameters.base-branch >>; then
              echo "‚úÖ Rebase successful"
            else
              if [ "<< parameters.auto-resolve-conflicts >>" = "true" ]; then
                echo "Attempting to auto-resolve conflicts..."

                # Accept ours for specific files
                git checkout --ours pyproject.toml 2>/dev/null || true
                git checkout --ours setup.py 2>/dev/null || true
                git add -A

                if git rebase --continue; then
                  echo "‚úÖ Auto-resolution successful"
                else
                  echo "‚ùå Manual conflict resolution required"
                  git rebase --abort
                  exit 1
                fi
              else
                echo "‚ùå Rebase failed - manual resolution required"
                git rebase --abort
                exit 1
              fi
            fi
      - when:
          condition: << parameters.force-push >>
          steps:
            - run:
                name: Force push rebased branch
                command: |
                  git push --force-with-lease origin HEAD
                  echo "‚úÖ Branch rebased and pushed"

# Jobs
jobs:
  code-quality:
    description: "Run full code quality suite"
    executor: python
    parameters:
      checkout-code:
        type: boolean
        default: true
        description: "Checkout repository code"
      run-format:
        type: boolean
        default: true
        description: "Run formatting"
      run-lint:
        type: boolean
        default: true
        description: "Run linting"
      line-length:
        type: integer
        default: 100
        description: "Maximum line length"
      auto-commit:
        type: boolean
        default: false
        description: "Auto-commit formatting changes"
    steps:
      - when:
          condition: << parameters.checkout-code >>
          steps:
            - checkout
      - restore_cache:
          keys:
            - pip-v1-{{ checksum "requirements.txt" }}-{{ checksum "requirements-dev.txt" }}
            - pip-v1-{{ checksum "requirements.txt" }}
            - pip-v1-
      - run:
          name: Install dependencies
          command: |
            if [ -f requirements.txt ]; then
              pip install -r requirements.txt
            fi
            if [ -f requirements-dev.txt ]; then
              pip install -r requirements-dev.txt
            fi
      - when:
          condition: << parameters.run-format >>
          steps:
            - format:
                line-length: << parameters.line-length >>
                auto-commit: << parameters.auto-commit >>
      - when:
          condition: << parameters.run-lint >>
          steps:
            - lint:
                max-line-length: << parameters.line-length >>
                fail-on-error: false
      - save_cache:
          key: pip-v1-{{ checksum "requirements.txt" }}-{{ checksum "requirements-dev.txt" }}
          paths:
            - /tmp/pip-cache

  pr-review:
    description: "Automated PR review with Danger"
    executor: python
    parameters:
      min-coverage:
        type: integer
        default: 80
        description: "Minimum test coverage"
    steps:
      - checkout
      - danger:
          min-coverage: << parameters.min-coverage >>

# Examples
examples:
  basic-formatting:
    description: "Basic code formatting with auto-commit"
    usage:
      version: 2.1
      orbs:
        python-quality: branchbutler-labs/python-quality@1.0.0
      workflows:
        format-code:
          jobs:
            - python-quality/code-quality:
                run-format: true
                run-lint: false
                auto-commit: true

  full-quality-check:
    description: "Complete code quality check with formatting and linting"
    usage:
      version: 2.1
      orbs:
        python-quality: branchbutler-labs/python-quality@1.0.0
      workflows:
        quality-check:
          jobs:
            - python-quality/code-quality:
                line-length: 100
                auto-commit: false
                context: branchbutler

  pr-automation:
    description: "Automated PR review workflow"
    usage:
      version: 2.1
      orbs:
        python-quality: branchbutler-labs/python-quality@1.0.0
      workflows:
        pr-workflow:
          jobs:
            - python-quality/code-quality:
                filters:
                  branches:
                    ignore: main
            - python-quality/pr-review:
                requires:
                  - python-quality/code-quality

  custom-command:
    description: "Using individual commands in custom jobs"
    usage:
      version: 2.1
      orbs:
        python-quality: branchbutler-labs/python-quality@1.0.0
      jobs:
        my-custom-job:
          executor: python-quality/python
          steps:
            - checkout
            - python-quality/format:
                line-length: 120
                auto-commit: true
            - python-quality/lint:
                fail-on-error: true
      workflows:
        main:
          jobs:
            - my-custom-job
